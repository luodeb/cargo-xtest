use anyhow::{Context, Result};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::types::{CargoToml, ProjectConfig};

/// Locate the workspace root (parent of the `xtask/` directory).
pub fn project_root() -> PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask must live inside a subdirectory of the project root")
        .to_path_buf()
}

/// Read `.config.toml` and return (active_keys, all_keys).
pub fn load_active_xconfigs(root: &Path) -> Result<(Vec<String>, Vec<String>)> {
    let config_path = root.join(".config.toml");
    let config_str = std::fs::read_to_string(&config_path)
        .with_context(|| format!("read {}", config_path.display()))?;
    let config: ProjectConfig = toml::from_str(&config_str).context("parse .config.toml")?;

    let map = config.xconfig.unwrap_or_default();
    let all_keys: Vec<String> = map.keys().cloned().collect();
    let active: Vec<String> = map
        .into_iter()
        .filter(|(_, enabled)| *enabled)
        .map(|(k, _)| k)
        .collect();

    Ok((active, all_keys))
}

/// Scan a `Cargo.toml` for `[package.metadata.xconfig]`.
/// Populates `feature_map`: target_crate → Vec<feature_name>
pub fn collect_xconfig_metadata(
    cargo_toml: &Path,
    active: &[String],
    feature_map: &mut HashMap<String, Vec<String>>,
) -> Result<()> {
    let content = std::fs::read_to_string(cargo_toml)?;
    let parsed: CargoToml =
        toml::from_str(&content).with_context(|| format!("parse {}", cargo_toml.display()))?;

    let xconfig = match parsed.package.and_then(|p| p.metadata).and_then(|m| m.xconfig) {
        Some(x) => x,
        None => return Ok(()),
    };

    for key in active {
        if let Some(specs) = xconfig.get(key) {
            for spec in specs {
                // spec = "crate_name/feature_name"
                if let Some((crate_name, feature)) = spec.split_once('/') {
                    feature_map
                        .entry(crate_name.to_string())
                        .or_default()
                        .push(feature.to_string());
                }
            }
        }
    }
    Ok(())
}

/// Walk `crates/` and top-level packages to collect the full feature_map.
pub fn collect_all_metadata(
    root: &Path,
    active: &[String],
) -> Result<HashMap<String, Vec<String>>> {
    let mut feature_map: HashMap<String, Vec<String>> = HashMap::new();

    let crates_dir = root.join("crates");
    if crates_dir.is_dir() {
        for entry in std::fs::read_dir(&crates_dir)? {
            let path = entry?.path();
            let toml_path = path.join("Cargo.toml");
            if toml_path.exists() {
                collect_xconfig_metadata(&toml_path, active, &mut feature_map)?;
            }
        }
    }
    for name in ["entry"] {
        let toml_path = root.join(name).join("Cargo.toml");
        if toml_path.exists() {
            collect_xconfig_metadata(&toml_path, active, &mut feature_map)?;
        }
    }

    Ok(feature_map)
}

/// Regenerate `.cargo/config.toml` so that rust-analyzer picks up
/// the active xconfig cfgs via `[build] rustflags`.
pub fn sync_cargo_config(root: &Path, active: &[String], all_keys: &[String]) -> Result<()> {
    let mut content = String::from("\
# Auto-generated by xtask — do not edit manually.\n\
# Run `cargo xtask` to regenerate after changing .config.toml.\n\
\n\
[alias]\n\
xtask = \"run -p xtask --\"\n\
");

    let mut flags: Vec<String> = Vec::new();
    // --cfg for active keys only
    for c in active {
        flags.push(format!("\"--cfg={}\"" , c.to_uppercase()));
    }
    // --check-cfg for ALL known keys (so rust-analyzer never warns)
    for c in all_keys {
        flags.push(format!("\"--check-cfg=cfg({})\"", c.to_uppercase()));
    }
    flags.push("\"--check-cfg=cfg(__xfp,values(any()))\"".to_string());

    content.push_str(&format!(
        "\n[build]\nrustflags = [{}]\n",
        flags.join(", ")
    ));

    let config_path = root.join(".cargo").join("config.toml");
    let existing = std::fs::read_to_string(&config_path).unwrap_or_default();
    if existing != content {
        std::fs::create_dir_all(root.join(".cargo"))?;
        std::fs::write(&config_path, &content)?;
        eprintln!("[xtask] synced .cargo/config.toml");
    }
    Ok(())
}
