mod config;
mod resolve;
mod types;
mod wrapper;

use anyhow::{bail, Context, Result};
use std::collections::{HashMap, HashSet};
use std::process::{Command, Stdio};

use config::project_root;
use types::{CargoMessage, DepSource, ExternDep};

// ── Orchestrator ─────────────────────────────────────────────────────

fn xtask_main() -> Result<()> {
    let root = project_root();
    let cargo_args: Vec<String> = std::env::args().skip(1).collect();

    // 1. Read .config.toml
    let (active, all_keys) = config::load_active_xconfigs(&root)?;
    eprintln!("[xtask] active xconfigs: {active:?}");

    // 2. Collect [package.metadata.xconfig] → feature_map
    let feature_map = config::collect_all_metadata(&root, &active)?;
    eprintln!("[xtask] feature injection: {feature_map:?}");

    // 3. Auto-resolve extern injection for all features
    let extern_map = resolve::resolve_extern_map(&root, &feature_map)?;

    eprintln!("[xtask] extern injection (auto-resolved): {extern_map:?}");

    // Collect all unique ExternDeps we need rlibs for
    let all_extern_deps: Vec<ExternDep> = extern_map
        .values()
        .flatten()
        .cloned()
        .collect::<Vec<_>>();

    let needed_externs: Vec<String> = all_extern_deps
        .iter()
        .map(|d| d.crate_name.clone())
        .collect::<HashSet<_>>()
        .into_iter()
        .collect();

    // 4. Phase 1: auto-generate xdeps/Cargo.toml and build it
    let mut rlib_paths: HashMap<String, String> = HashMap::new();

    if !needed_externs.is_empty() {
        // Generate target/xdeps/Cargo.toml from resolved deps
        let xdeps_dir = root.join("target").join("xdeps");
        std::fs::create_dir_all(xdeps_dir.join("src"))?;

        // Deduplicate by pkg_name
        let mut seen = HashSet::new();
        let mut dep_lines = Vec::new();
        for dep in &all_extern_deps {
            if seen.insert(dep.pkg_name.clone()) {
                let spec = match &dep.source {
                    DepSource::Git(url) => format!("{} = {{ git = \"{}\" }}", dep.pkg_name, url),
                    DepSource::Path(p) => format!("{} = {{ path = \"{}\" }}", dep.pkg_name, p),
                    DepSource::Registry { version, features, default_features } => {
                        let mut parts = vec![format!("version = \"{}\"", version)];
                        if !features.is_empty() {
                            let feat_list = features.iter()
                                .map(|f| format!("\"{}\"", f))
                                .collect::<Vec<_>>()
                                .join(", ");
                            parts.push(format!("features = [{}]", feat_list));
                        }
                        if !default_features {
                            parts.push("default-features = false".to_string());
                        }
                        format!("{} = {{ {} }}", dep.pkg_name, parts.join(", "))
                    }
                };
                dep_lines.push(spec);
            }
        }
        dep_lines.sort();

        let xdeps_toml = format!(
            "# AUTO-GENERATED by xtask — do not edit manually\n\
             [workspace]\n\
             \n\
             [package]\n\
             name = \"xdeps\"\n\
             version = \"0.1.0\"\n\
             edition = \"2024\"\n\
             \n\
             [dependencies]\n\
             {}\n",
            dep_lines.join("\n")
        );

        let xdeps_toml_path = xdeps_dir.join("Cargo.toml");
        let existing = std::fs::read_to_string(&xdeps_toml_path).unwrap_or_default();
        if existing != xdeps_toml {
            std::fs::write(&xdeps_toml_path, &xdeps_toml)?;
            eprintln!("[xtask] regenerated xdeps/Cargo.toml");
        }

        // Ensure lib.rs exists
        let lib_rs = xdeps_dir.join("src").join("lib.rs");
        if !lib_rs.exists() {
            std::fs::write(&lib_rs, "// Auto-generated: ensures optional deps are compiled.\n")?;
        }

        eprintln!("[xtask] Phase 1: building xdeps for rlibs: {needed_externs:?}");

        let xdeps_manifest = xdeps_dir.join("Cargo.toml");
        let output = Command::new("cargo")
            .args(["build", "--manifest-path", &xdeps_manifest.to_string_lossy(), "--message-format=json"])
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .current_dir(&root)
            .output()
            .context("failed to run cargo build for xdeps")?;

        if !output.status.success() {
            bail!("Phase 1 (build xdeps) failed");
        }

        for line in String::from_utf8_lossy(&output.stdout).lines() {
            if let Ok(msg) = serde_json::from_str::<CargoMessage>(line) {
                if msg.reason == "compiler-artifact" {
                    if let (Some(target), Some(filenames)) = (msg.target, msg.filenames) {
                        let name = target.name.replace('-', "_");
                        if needed_externs.contains(&name) {
                            if let Some(rlib) = filenames.iter().find(|f| f.ends_with(".rlib")) {
                                rlib_paths.insert(name, rlib.clone());
                            }
                        }
                    }
                }
            }
        }

        for ext in &needed_externs {
            if !rlib_paths.contains_key(ext) {
                bail!("rlib for extern `{ext}` not found after building xdeps");
            }
        }

        eprintln!("[xtask] rlib paths: {rlib_paths:?}");
    } else {
        // No externs needed — write an empty target/xdeps/Cargo.toml
        let xdeps_dir = root.join("target").join("xdeps");
        std::fs::create_dir_all(xdeps_dir.join("src"))?;
        let xdeps_toml = "# AUTO-GENERATED by xtask — do not edit manually\n\
             [workspace]\n\
             \n\
             [package]\n\
             name = \"xdeps\"\n\
             version = \"0.1.0\"\n\
             edition = \"2024\"\n\
             \n\
             [dependencies]\n";
        let xdeps_toml_path = xdeps_dir.join("Cargo.toml");
        let existing = std::fs::read_to_string(&xdeps_toml_path).unwrap_or_default();
        if existing != xdeps_toml {
            std::fs::write(&xdeps_toml_path, xdeps_toml)?;
        }
        let lib_rs = xdeps_dir.join("src").join("lib.rs");
        if !lib_rs.exists() {
            std::fs::write(&lib_rs, "// Auto-generated: ensures optional deps are compiled.\n")?;
        }
    }

    // Sync .cargo/config.toml for rust-analyzer (after Phase 1 so we have rlib_paths)
    config::sync_cargo_config(&root, &active, &all_keys, &rlib_paths)?;

    // 5. Encode env vars for the wrapper
    let features_env = feature_map
        .iter()
        .map(|(cn, fs)| format!("{cn}:{}", fs.join(",")))
        .collect::<Vec<_>>()
        .join(";");

    let mut extern_entries = Vec::new();
    for (crate_name, deps) in &extern_map {
        for dep in deps {
            if let Some(rlib_path) = rlib_paths.get(&dep.crate_name) {
                extern_entries.push(format!("{crate_name}:{}={rlib_path}", dep.crate_name));
            }
        }
    }
    let externs_env = extern_entries.join(";");

    // 6. Build RUSTFLAGS
    let mut rustflags = std::env::var("RUSTFLAGS").unwrap_or_default();
    for c in &active {
        rustflags.push_str(&format!(" --cfg={}", c.to_uppercase()));
    }
    // --check-cfg for ALL known keys, not just active ones
    for c in &all_keys {
        rustflags.push_str(&format!(" --check-cfg=cfg({})", c.to_uppercase()));
    }
    // Add xdeps deps dir to search path so transitive deps can find extern rlibs
    if let Some(first_rlib) = rlib_paths.values().next() {
        if let Some(deps_dir) = std::path::Path::new(first_rlib).parent() {
            rustflags.push_str(&format!(" -Ldependency={}", deps_dir.display()));
        }
    }
    if !features_env.is_empty() || !externs_env.is_empty() {
        use std::hash::{Hash, Hasher};
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        features_env.hash(&mut hasher);
        externs_env.hash(&mut hasher);
        let h = hasher.finish();
        rustflags.push_str(&format!(" --cfg=__xfp=\"{h:016x}\""));
    }
    rustflags.push_str(" --check-cfg=cfg(__xfp,values(any()))");
    let rustflags = rustflags.trim().to_string();

    // 7. Phase 2: build/run with RUSTC_WRAPPER
    let wrapper = std::env::current_exe().context("locate xtask binary")?;

    let default_args: Vec<String> = vec!["build".into(), "-p".into(), "entry".into()];
    let args: &[String] = if cargo_args.is_empty() {
        &default_args
    } else {
        &cargo_args
    };

    eprintln!("[xtask] Phase 2: RUSTFLAGS={rustflags}");
    eprintln!("[xtask] Phase 2: running cargo {}", args.join(" "));

    let mut cmd = Command::new("cargo");
    cmd.args(args);
    let status = cmd
        .env("RUSTC_WRAPPER", &wrapper)
        .env("__XCONFIG_WRAPPER", "1")
        .env("RUSTFLAGS", &rustflags)
        .env("XCONFIG_FEATURES", &features_env)
        .env("XCONFIG_EXTERNS", &externs_env)
        .current_dir(&root)
        .status()
        .context("cargo failed")?;

    if !status.success() {
        bail!("cargo exited with {status}");
    }
    Ok(())
}

// ── Entry point ──────────────────────────────────────────────────────

fn main() -> Result<()> {
    if std::env::var("__XCONFIG_WRAPPER").is_ok() {
        wrapper::wrapper_main()
    } else {
        xtask_main()
    }
}
